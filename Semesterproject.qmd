---
title: "Wartezeit an ÖV-Haltestellem beim Reisebeginn"
date: 07.02.2023
authors: Stefan Häring & Miriam Jakob
format:
  html:
    code-fold: true # Code ist dadurch aufklappbar
    toc: true # Macht Inhaltsverzeichnis
    toc-title: Inhaltsverzeichnis # Titel des Inhaltsverzeichnisses
    toc-location: left # Macht inhaltsverzeichnis links
    toc-expand: 3 # ganzes Verzeichnis wird angezeigt
execute: 
  warning: false # keine Warnungen
  messages: false # keine Nachrichten
  echo: false # Zeigt kein code, wenn nicht verlangt
---

# 1 Hintergrund und Forschungsziele

Passagiere empfinden in der Regel das Warten an Haltestellen des Öffentlichen Verkehrs (ÖV) als äusserst lästig (Van Hagen 2011). Die Schweizer ÖV sind international bekannt für ihre Pünktlichkeit (Kaindl 2022), wodurch die Länge der Wartezeit zu Beginn einer Reise meist selbstverschuldet ist. Nach Csiskos & Currie (2008) gibt es zwei verschiedene Arten von Fahrgastverhalten: Eine Gruppe kommt zufällig an, während eine andere Gruppe aktiv versucht, ihre Wartezeit zu minimieren, indem sie rechtzeitig zur geplanten Abfahrtszeit bei der Haltestelle ankommt.

In unserer Projektarbeit möchten wir unsere tägliche Wartezeit an ÖV-Haltestellen untersuchen. Dabei wird ausschliesslich der Beginn einer Reise betrachtet. Folgende Fragen sollen anhand zweier leicht unterschiedlicher methodischen Ansätzen beantwortet werden:

-   Wie oft reisen wir mit den ÖV?
-   Sind die Wartezeiten pro Person von Reise zu Reise unterschiedlich lang?
-   Wer verbringt durchschnittlich mehr Wartezeit an den ÖV-Haltestellen?
-   Kommen unsere beiden methodischen Ansätze zu den gleichen Resultaten?

# 2 Methode

## 2.1 Daten

Unsere Daten wurden in RStudio (Posit team 2023) mit der R Version 4.2.1 (R-Core Team, 2022) analysiert. Die Daten bestehen aus eigenen Bewegungsdaten, welche mit der Applikation Posmo Project (Datamap AG, Version 22.01.16, 2023) erfasst wurden (Abildung 1). Daten wurden vom 03.05.23 bis 21.06.23 mit einer Frequenz der Lokalisierungsdaten von 10 Sekunden aufgenommen. Fand keine deutliche Bewegung statt, wurden die Datenpunkte durch Posmo automatisch entfernt. Die Daten liegen als CSV-Datei vor und beinhalten u.a. Datum & Zeit („datetime"), x-Koordinaten („long_x"), y-Koordinaten („lat_y") und Transportmodus („transport_mode").

```{r}
### R: Libraries laden

library("readr")
library("tidyr") 
library("ggplot2")
library("dplyr")
library("sf")
library(treemapify)
library(ggmosaic)
library(cowplot)
library(leaflet)
```

```{r}
### R: Daten einlesen

# Daten von Stefan (ab 29.04.2023)
stefan <- read_delim("posmo_Stefan_23-05-03_06-21.csv", delim = ",")
head(stefan)
stefan$person <- "Stefan"


# Daten von Miriam (ab xx.05.2023)
miriam <- read_delim("posmo_Miriam_23-05-03_06-21.csv", delim = ",")
miriam$person <- "Miriam"

# Schweizergrenze für Visualisierung
schweiz <- read_sf("schweiz.gpkg")

# Daten zusammenführen
posmo <- rbind(stefan, miriam)

# nicht relevante Spalten entfernen
posmo <- posmo |> 
  select(-user_id, -weekday, -place_name)

# NA finden & entfernen
# posmo[!complete.cases(posmo), ] # Zeigt Zeilen mit NA an
posmo <- drop_na(posmo)# Spalten mit NA entfernen

# Geometrie hinzufügen
posmo <- posmo |> 
  st_as_sf(coords = c("lon_x", "lat_y"), crs = 4326, remove = FALSE) |>  # Geometrie hinzufügen
  st_transform(2056) # transformieren CH1903+ LV95: 2056

# Schweizer Koordinaten zu sf-Tabelle hinzufügen
posmo_coordinates <- st_coordinates(posmo)
posmo <- cbind(posmo, posmo_coordinates)

# WGS Koordinaten entfernen 
posmo <- posmo |> 
  select(-lon_x, -lat_y)

# Daten anschauen, Trajectories
# ggplot(posmo, aes(X, Y, color = person))+
#   geom_path()+
#   coord_equal()+
#   scale_color_manual(values = c("Miriam" = "#3182bd", "Stefan" = "#c51b8a"))+
#   theme_void()
```

```{r abbildung1, fig.cap="*Abbildung 1: Alle Datenpunkte aus der Zeitspanne vom 03.05. bis 21.06.2023 von Miriam und Stefan*"}
# posmo_filtered <- posmo |>  # nur posmo daten innerhalb Rechteck um schweiz
#   st_crop(st_as_sfc(st_bbox(schweiz)))
# 
# ggplot()+
#   geom_sf(data = schweiz, fill= NA)+
#   geom_sf(data = posmo_filtered, aes(colour = person))+
#   scale_color_manual(values = c("Miriam" = "#3182bd", "Stefan" = "#c51b8a"))+
#   labs(
#     color = "Person")+ # Legende beschriften
#   theme_void() # Achsen und Raster verschwinden

posmo_clipped <- st_intersection(posmo, schweiz) # nur posmo daten innerhalb von schweiz, geht lange, sollte aber gehen...

ggplot()+
   geom_sf(data = schweiz, fill= NA)+
   geom_sf(data = posmo_clipped, aes(colour = person))+
   scale_color_manual(values = c("Miriam" = "#3182bd", "Stefan" = "#c51b8a"))+
   theme_void() # Achsen und Raster verschwinden
```

Zusätzlich wird der Datensatz „Haltestellen des öffentlichen Verkehrs" vom Bundesamt für Verkehr (BAV 2015) verwendet, welcher alle ÖV-Haltestellen beinhaltet.

## 2.2 Datenvorverarbeitung

Die Posmo-App ist noch in der Entwicklung und zeichnet die Transportmodi nicht immer korrekt auf. Die Daten wurden deshalb von uns auf POSMO (datamap.io) überprüft und falls nötig der Transportmodus (Bsp. "Train", "Walk", usw.) von Hand angepasst.

## 2.3 Methode

### 2.3.1 Ansatz «Geschwindigkeit»

Um den Start einer Reise zu finden, werden die Daten auf eine bestimmte Abfolge von Bewegungen (Segmente, siehe auch Laube 2017) durchsucht. Zu Beginn der Abfolge darf keine Bewegung stattfinden, man ist zum Beispiel zu Hause oder bei der Arbeit. Dafür muss zwischen zwei Datenpunkten eine Zeitdifferenz über einem gewählten Schwellenwert liegen. Hierfür haben wir einen schwellenwert von zehn Minuten gewählt, da wir davon ausgehen, dass wir nie länger als 10 Minuten an einer ÖV-Haltestelle warten. Zudem sollte der Schwellenwert so tief wie möglich sein, damit auch Ausflüge (Bsp. Spaziergang, Feldarbeit, usw.), bei welchen eine kurze Pause eingelegt wird, in die Datenauswertung einfliessen.

Die restlichen Datenpunkte werden anhand der Geschwindigkeit in Segmente mit langsamer oder schneller Bewegung eingeteilt. Als "langsam" werden Bewegungen kleiner als 45 km/h klassifiziert. Die langsamen Bewegungen sollten die Bewegungen zu der ÖV-Haltestelle abdecken, welche zu Fuss oder mit dem Fahrrad zurückgelegt werden. Bewegungen gleich oder grösser als 45 km/h werden als "schnell" klassifiziert. Diese Bewegungen sollten die ÖV abdecken. Der Schwellenwert wurde so gewählt, da Stefan auf seinem Weg zur ÖV-Haltestelle Geschwindigkeiten von über 40 km/h erreicht.

```{r}
#### R: G: Geschwindigkeit berechnen

# Geschwindigkeit herausfinden
posmo1 <- posmo |> # Zeit
  mutate(
    time = as.numeric(difftime(lead(datetime), datetime, units = "secs")) # secs
  ) # Hier gibt es manchmal 0er, also Datenpunkte zur selben Zeit. Die müssten auch selbe Koordinaten haben und sind für Geschwindigkeitsrechnung nicht zu gebrauchen. Also weg damit... 
# Hier muss "lead" anstatt "lag" benutzt werden

posmo1 <- posmo1 |> # time = 0 entfernen
  mutate(time = ifelse(time == 0, NA, time)) |> 
  drop_na()

posmo1 <- posmo1 |>
  mutate(
    steplength = round(sqrt((lead(X,1)-X)^2+(lead(Y,1)-Y)^2),1), # meter
    velocity = round((steplength/1000)/(time/60/60),1) # km/h
  )
```

```{r}
#### R: G: Einteilung stay/slow/fast

# Erfahrungswerte:

# Stefans Weg zum Bahnhof mit dem Fahrrad, maximale Geschwindigkeit:
# 29.04.2023 09:09:40: 43.0 km/h
# 08.05.2023 14:35:29: 36.0 km/h

# Miriams Bus:
# Bsp. 35 km/h

# Miriam rennt zum Bus
# Bsp. 17 km/h

# Schwellenwert setzen slow/fast, velocity: slow < 45 km/h <= fast
# Schwellenwert setzen stay, time: stay >= 600 (10 min) # ACHTUNG: Wenn jemand länger als Schwellenwert wartet, wird dies nicht als Reisestart gefunden.

posmo1 <- posmo1 |> 
  mutate(velocity_text = ifelse(velocity < 45, "slow", "fast"))
posmo1$velocity_text[posmo1$time >= 600] <- "stay"

# ÜBERLEGUNG: Ausreisser entfernen
# Mir ist nur derjenige vom 2023-04-29 09:43:01 aufgefallen...

# Wie kann ich dieses Problem alternativ angegangen werden???

# Vorgehen 1: Alle Punkte welche plötzlich einen Geschwindigkeitsunterschied von 30 km/h als benachbarte Punkte aufweisen, werden gelöscht
# posmo1$ausreisser[
  # sqrt((posmo1$velocity-lag(posmo1$velocity))^2) > 30 & 
  # sqrt((posmo1$velocity-lead(posmo1$velocity))^2) > 30
  # ] <- "NA"
# Fazit: nun gibt es bei jeder Beschleunigung einen Ausreisser, also nicht geeignet

# Vorgehen 2: Alle Punkte, welche in velocity_text von den direkten Nachbarn abweichen werden als Ausreisser markiert, stay ist davon ausgenommen
# posmo1$ausreisser[
  # posmo1$velocity_text != lag(posmo1$velocity_text) & 
  # posmo1$velocity_text != lead(posmo1$velocity_text) &
  # posmo1$velocity_text != "stay"
  # ] <- "NA" 
# Fazit: hier werden kurze Bahn/Busstrecken weggelöschen, bei welcher die Geschwindigkeit immer um den Schwellenwert slow/fast liegt. Für die Auswertung ist dies etwa gleich Schlimm wie Vorgehen 1 (oder???)

# Fazit Vorgehen 1&2: durch die Vorgehen gehen mehr korrekte Daten verloren als Ausreisser. Insgesamt habe ich nur einen Ausreisser gefunden.

# Vorgehen 3: weiter unten werden durch die Suche von Abfolge stay-slow-slow-fast-fast Aussreiser entfernt. Bzw. sie würden Startpunkte verbergen. Annahme: wir haben eine genügend grosse Stichprobengrösse, dass das wegfallen von Reisestartpunkten keine Rolle spielt. Somit hat sich die Suche nach Ausreissern erledigt.

```

Um den Start einer Reise zu finden, muss folgende Abfolge der Segmente vorliegen:

-   keine Bewegung
-   langsame Bewegung
-   schnelle Bewegung

Die Wartezeit kann anschliessend für alle gefundenen Events berechnet werden (Wartezeit = difftime (min(Segment schnell), max(Segment langsam))).

```{r}
#### R: G: Evente finden

# Event finden (stay-slow-fast), event_id

# Start und Enpunkte von Segment mit TRUE markieren
event <- posmo1 |> 
  mutate(find = ifelse(
      velocity_text != lead(velocity_text) |
      velocity_text != lag(velocity_text)
      , TRUE, NA))

# Nur Start und Enpunkte von Segment behalten
event <- drop_na(event)
event <- event |> 
  select(-find) # unnötige Spalten entfernen

# Abfolge stay-slow-slow-fast-fast finden, so werden auch Ausreisser eliminiert
event <- event |> # Start der Abfolge finden, TRUE
  mutate(find = ifelse(
      velocity_text == "stay" &
      lead(velocity_text, 1) == "slow" &
      lead(velocity_text, 2) == "slow" &
      lead(velocity_text, 3) == "fast" &
      lead(velocity_text, 4) == "fast"
      , TRUE, NA))

# nur Start Wartezeit und Ende Wartezeit behalten
event <- event |> # nur Ende slow (= Start Wartezeit) und Start fast (= Ende Wartezeit) markieren
  mutate(find = ifelse(
      lag(find, 2) == TRUE |
      lag(find, 3) == TRUE
      , TRUE, NA))

event <- drop_na(event) # nur Start & Ende Wartezeit behalten behalten
event <- event |> 
  select(-find) # unnötige Spalten entfernen

# Standort des Events bestimmen
event <- event |>
  mutate(haltestelle_x = ifelse(
      velocity_text == "slow"
      , X, lag(X)))

event <- event |>
  mutate(haltestelle_y = ifelse(
      velocity_text == "slow"
      , Y, lag(Y)))

event <- st_drop_geometry(event) # Alte Geometrie entfernen

event <- event |> 
  select(-X, -Y, -time, -steplength, -velocity) # unnötige Spalten entfernen

# pro event eine Spalte (wide format pro event)
# FEHLER: wide <- pivot_wider(event, names_from = "velocity_text", values_from = "datetime") # Hier funktioniert etwas mit dem Datenformat nicht??? Vielleicht mit Join???

slow <- event |> 
  subset(velocity_text == "slow") # Tabelle slow

fast <- event |> 
  subset(velocity_text == "fast") # Tabelle fast


# FEHLER: join <- left_join(slow, fast, "haltestelle_y", suffix = c("_slow", "_fast")) #Hier funktioniert etwas noch nicht??? Vielleicht ID geben

slow$id <- as.character(1:nrow(slow)) # id
fast$id <- as.character(1:nrow(slow)) # id

event <- left_join(slow, fast, "id", suffix = c("_slow", "_fast"))

event <- event |> # checken, ob standorte gleich sind (ob id richtig verteilt wurden)
  mutate(check = ifelse(
      haltestelle_x_slow == haltestelle_x_fast &
      haltestelle_y_slow == haltestelle_y_fast
      , TRUE, NA))
# event[!complete.cases(event), ] # alle id richtig

# names(event)
event <- event |> 
  select(-velocity_text_slow, -person_fast, -velocity_text_fast, -haltestelle_x_fast,
         -haltestelle_y_fast, -check) |> # unnötige Spalten entfernen
  rename(person = person_slow, X = haltestelle_x_slow, Y = haltestelle_y_slow, 
         start_warten = datetime_slow, ende_warten = datetime_fast) |>  # Spalten umbennenen
  st_as_sf(coords = c("X", "Y"), crs = 2056, remove = FALSE) # Geometrie hinzufügen
```

Die räumlichen Startpunkte der Reisen wurden mit den ÖV-Haltestellen aus dem Datensatz „Haltestellen des öffentlichen Verkehrs" validiert, wodurch Reisen mit dem Auto wegfallen, welche ebenfalls schnelle Segmente darstellen. Dafür wurde ein Buffer von 100 Metern um ÖV-Haltestellen mit den Positionsdaten der Wartezeit verschnitten. Die 100 Meter wurden gewählt, da die Warteposition auf einem Perron stark vom Punkt der ÖV-Haltestelle aus dem verwendeten Datensatz abweichen kann. Einen noch höheren Wert konnte jedoch nicht verwendet werden, da Autoreisen in knapp über 100 Metern Entfernung zu ÖV-Haltestellen gestartet wurden. Die verbleibenden Datenpunkte geben die für uns relevanten Events an (Abbildung 2).

```{r}
#### R: G: Evente validieren

# Bahnhöfe einlesen
haltestelle <- read_delim("haltestellen-oev_2056_de.csv/Betriebspunkt.csv", delim = ",")

haltestelle <- haltestelle |> 
  st_as_sf(coords = c("E", "N"), crs = 2056, remove = FALSE) |> # Geometrie hinzufügen
  subset(Betriebspunkttyp_Bezeichnung == "Haltestelle" |
           Betriebspunkttyp_Bezeichnung == "Haltestelle und Bedienpunkt") # nur Haltestellen

# ggplot(haltestelle)+
#   geom_sf()+
#   geom_sf(data = event, aes(colour = person), size = 2)+
#   scale_color_manual(values = c("Miriam" = "#3182bd", "Stefan" = "#c51b8a"))+
#   theme_void() # Achsen und Raster verschwinden

# Buffer um Bahnhof
haltestelle_buffer <- st_buffer(haltestelle, 100) # Was ist eine gute Buffer-Grösse???

# Intersect Buffer mit Event
haltestelle_event <- st_intersection(haltestelle_buffer, event)

# nur eine Haltestelle pro Event
haltestelle_event <- haltestelle_event |> 
  mutate(check = ifelse(
      id == lag(id) &
        id != 1, NA, TRUE)) |> 
  drop_na(check)
  
# Spalten aufräumen
haltestelle_event <- haltestelle_event |> 
  select(id, xtf_id, Name, E, N, person, start_warten, ende_warten) |>
  st_drop_geometry() |> 
  st_as_sf(coords = c("E", "N"), crs = 2056, remove = FALSE)

# Umlaute korrigieren
# haltestelle_event$Name[haltestelle_event$Name == "W\xe4denswil, Bahnhof"] <- "Waedenswil, Bahnhof" # Funktioniert nicht?!
# haltestelle_event$Name[haltestelle_event$Name == "W�denswil, Bahnhof"] <- "Waedenswil, Bahnhof" # Funktioniert nicht?!
haltestelle_event$Name[haltestelle_event$E == 2693625 & 
                       haltestelle_event$N == 1231675  ] <- "Wädenswil, Bahnhof"
haltestelle_event$Name[haltestelle_event$E == 2794912 & 
                       haltestelle_event$N == 1165431 ] <- "S-chanf, Chesa cumünela"
haltestelle_event$Name[haltestelle_event$E == 2684431 & 
                       haltestelle_event$N == 1240184 ] <- "Rüschlikon"

# Visualisierung: Wo wurde gewartet
# ggplot(haltestelle_event)+
#   geom_sf(data = schweiz)+
#   geom_sf()+
#   theme_void() # Achsen und Raster verschwinden
```

```{r abbildung2, fig.cap="*Abbildung 2: Alle ÖV-Haltestellen, bei welchen am Start einer Reise gewartet wurde*"}

# Visualisierung: Wer hat wo gewartet
ggplot(haltestelle_event)+
  geom_sf(data = schweiz, fill = NA)+
  geom_sf(aes(colour = person))+
  scale_color_manual(values = c("Miriam" = "#3182bd", "Stefan" = "#c51b8a"))+
  labs(
    color = "Person")+ # Legende beschriften
  theme_void() # Achsen und Raster verschwinden
```

Einige ÖV-Haltestellen werden dabei öfters benutzt als andere (Abbildung 3).

```{r abbildung3, fig.cap="*Abbildung 3: Benutzte ÖV-Haltestellen. Die grösse der Kästchen gibt die Anzahl Benutzungen an.*"}
# Treemap mit Start-ÖV-Haltestellen
haltestelle_treemap <- haltestelle_event |> 
  group_by(Name, person) |> # group_by(Spalte_gruppieren1, Spalte_gruppieren2)
  summarise(Anzahl = length(Name))

ggplot(haltestelle_treemap, aes(area = Anzahl, fill = person, 
                             subgroup = person, label = Name)) +
  geom_treemap()+
  geom_treemap_text(colour = "white", place = "centre", grow = TRUE)+
  scale_fill_manual(values = c("Miriam" = "#3182bd", "Stefan" = "#c51b8a"))+
    labs( # Beschriftung aendern
    fill = "Person")+
  theme_classic() # löscht ggplot-Layout
```

```{r}
#### R: G: Velocity: Wartezeit berechnen

# wartezeit pro Event: difftime(max(Segmentslow), min(segmentfast)
velocity <- haltestelle_event |> 
  mutate(wartezeit = round(as.numeric(difftime(ende_warten, start_warten, units = "mins")),2)) # ich glaube, die Daten sind nicht so gut...

# Spalte mit Kategorie der Wartezeit hinzufügen
velocity$wartezeit_cat <- "NA"
velocity$wartezeit_cat[velocity$wartezeit >= 0 & velocity$wartezeit < 1] <- "0-1"
velocity$wartezeit_cat[velocity$wartezeit >= 1 & velocity$wartezeit < 2] <- "1-2"
velocity$wartezeit_cat[velocity$wartezeit >= 2 & velocity$wartezeit < 3] <- "2-3"
velocity$wartezeit_cat[velocity$wartezeit >= 3 & velocity$wartezeit < 4] <- "3-4"
velocity$wartezeit_cat[velocity$wartezeit >= 4 & velocity$wartezeit < 5] <- "4-5"
velocity$wartezeit_cat[velocity$wartezeit >= 5 & velocity$wartezeit < 6] <- "5-6"
velocity$wartezeit_cat[velocity$wartezeit >= 6 & velocity$wartezeit < 7] <- "6-7"
velocity$wartezeit_cat[velocity$wartezeit >= 7 & velocity$wartezeit < 8] <- "7-8"
velocity$wartezeit_cat[velocity$wartezeit >= 8 & velocity$wartezeit < 9] <- "8-9"
velocity$wartezeit_cat[velocity$wartezeit >= 9 & velocity$wartezeit < 10] <- "9-10"
```

### 2.3.2 Ansatz «Transportmodus»

Um zu validieren, wie gut der Ansatz "Geschwindigkeit" funktioniert, machen wir eine zusätzliche Analyse mit den Angaben der Transportmodi. Auch hier gehen wir davon aus, dass wir nie länger als zehn Minuten auf das ÖV warten.

```{r}
### R: T: Ansatz "Transportmodus"

#### R: T: Einteilung stay/slow/public

# Zeitdauer herausfinden
posmo2 <- posmo |> # Zeit
  mutate(
    time = as.numeric(difftime(lead(datetime), datetime, units = "secs")) # secs
  ) # Hier gibt es manchmal 0er, also Datenpunkte zur selben Zeit. Die müssten auch selbe Koordinaten haben und sind für Geschwindigkeitsrechnung nicht zu gebrauchen. Also weg damit... 
# Hier muss "lead" anstatt "lag" benutzt werden

posmo2 <- posmo2 |> # time = 0 entfernen
  mutate(time = ifelse(time == 0, NA, time)) |> 
  drop_na()

# Schwellenwert setzen stay, time: stay >= 600 (10 min) # Schwellenwert evtl. nach oben setzen, da Stefan mal 40 min auf Zug wartete - Wenn jemand länger als Schwellenwert wartet, wird dies nicht als Reisestart gefunden.
#neue Spalte "Moving", neuer Wert "Stay", sonst alle anderen Transportmittel beibehalten

posmo2 <- posmo2 |> 
  mutate(Moving = ifelse(time >= 600, "Stay", transport_mode))

#Umbenennen/einteilen der Transportmittel, Public: Boat, Bus, Train, Tram.Slow: Bike, Walk. Stay: stay. Alles andere: other
posmo2 <- posmo2 %>%
  mutate(moving_class = case_when(
    Moving == "Bus" ~ "public",
    Moving == "Train" ~ "public",  
    Moving == "Tram" ~ "public",  
    Moving == "Boat" ~ "public",
    Moving == "Walk" ~"slow",
    Moving == "Bike" ~"slow",
    Moving == "Stay" ~"stay",
    TRUE ~ "other"
  ))
```

Dabei werden die Daten auf eine bestimmte Abfolge anhand des angegebene Transportmodus durchsucht.

-   keine Bewegung
-   Transportmodus Walk/Bike
-   Transportmodus Bus/Train/Tram

Die Wartezeit kann anschliessend für alle gefundenen Events berechnet werden (Wartezeit = difftime (min(Segment schnell), max(Segment langsam))).

```{r}
#### R: T: Evente finden

#Abfolge, Stay, Walk/Bike, Bus/Train/Tram
# Start und Enpunkte von Segment mit TRUE markieren

event <- posmo2 |> 
  mutate(find= ifelse(
    moving_class != lead(moving_class) |
    moving_class != lag(moving_class)
    , TRUE, NA))


# Nur Start und Enpunkte von Segment behalten
event <- drop_na(event)
event <- event |> 
  select(-find) # unnötige Spalten entfernen

# Abfolge stay-slow-slow-fast-fast finden, so werden auch Ausreisser eliminiert
event <- event |> # Start der Abfolge finden, TRUE
  mutate(find = ifelse(
    moving_class == "stay" &
      lead(moving_class, 1) == "slow"&
      lead(moving_class, 2) == "slow" &
      lead(moving_class, 3) == "public" &
      lead(moving_class, 4) == "public"
    , TRUE, NA))

# nur Start Wartezeit und Ende Wartezeit behalten

event <- event |> # nur Ende slow (= Start Wartezeit) und Start fast (= Ende Wartezeit) markieren
  mutate(find = ifelse(
    lag(find, 2) == TRUE |
      lag(find, 3) == TRUE
    , TRUE, NA))

event <- drop_na(event) # nur Start & Ende Wartezeit behalten behalten
event <- event |> 
  select(-find) # unnötige Spalten entfernen

#vorbereitung für left_join, darf keine versch Geometrien in den zu kombinierenden tables haben
event <- st_drop_geometry(event) # Alte Geometrie entfernen

##separate tables machen, slow und public, dann left_join, unnötige spalten entfernen  (start und endzeiten behalten)

slow <- event |> 
  subset(moving_class == "slow") # Tabelle slow

public<-event |> 
  subset(moving_class == "public") #Tabelle public

#left join, via hinzugefügter id

slow$id <- as.character(1:nrow(slow)) # id
public$id <- as.character(1:nrow(slow)) # id

event <- left_join(slow,public,"id", suffix = c("_slow", "_public"))

# unnötige Spalten entfernen, verbleibende umbenennen
# names(event)
event <- event |> 
  select(-transport_mode_slow, -Moving_slow, -moving_class_slow,
         -transport_mode_public, -X_public, -Y_public, -time_public, -Moving_public, -moving_class_public, -person_public) |> # unnötige Spalten entfernen
  rename(E=X_slow, N=Y_slow, wartezeit_sec=time_slow, start_warten = datetime_slow, ende_warten = datetime_public, person=person_slow) # Spalten umbennenen

event <- event |> 
  mutate(wartezeit_minutes = as.numeric(difftime(ende_warten, start_warten, units = "mins")))
```

```{r}
# Bahnhöfe einlesen
haltestelle <- read_delim("haltestellen-oev_2056_de.csv/Betriebspunkt.csv", delim = ",") # WArum funktioniert das plötzlich nicht mehr??? File neu herunterladen!

haltestelle <- haltestelle |> 
  st_as_sf(coords = c("E", "N"), crs = 2056, remove = FALSE) |> # Geometrie hinzufügen
  subset(Betriebspunkttyp_Bezeichnung == "Haltestelle" |
           Betriebspunkttyp_Bezeichnung == "Haltestelle und Bedienpunkt") # nur Haltestellen

# Buffer um Bahnhof
haltestelle_buffer <- st_buffer(haltestelle, 100) # Was ist eine gute Buffer-Grösse???


# Intersect Buffer mit Event
event <- st_as_sf(event, coords = c("E", "N"), crs = 2056)
haltestelle_event <- st_intersection(haltestelle_buffer, event)

# nur eine Haltestelle pro Event
haltestelle_event <- haltestelle_event |> 
  mutate(check = ifelse(
      id == lag(id) &
        id != 1, NA, TRUE)) |> 
  drop_na(check)
  
# Spalten aufräumen
haltestelle_event <- haltestelle_event |> 
  select(id, xtf_id, Name, E, N, person, start_warten, ende_warten, wartezeit_minutes) |>
  st_drop_geometry() |> 
  st_as_sf(coords = c("E", "N"), crs = 2056, remove = FALSE)

# Umlaute korrigieren
# haltestelle_event$Name[haltestelle_event$Name == "W\xe4denswil, Bahnhof"] <- "Waedenswil, Bahnhof" # Funktioniert nicht?!
# haltestelle_event$Name[haltestelle_event$Name == "W�denswil, Bahnhof"] <- "Waedenswil, Bahnhof" # Funktioniert nicht?!
haltestelle_event$Name[haltestelle_event$E == 2693625 & 
                       haltestelle_event$N == 1231675  ] <- "Wädenswil, Bahnhof"
haltestelle_event$Name[haltestelle_event$E == 2794912 & 
                       haltestelle_event$N == 1165431 ] <- "S-chanf, Chesa cumünela"
haltestelle_event$Name[haltestelle_event$E == 2684431 & 
                       haltestelle_event$N == 1240184 ] <- "Rüschlikon"
haltestelle_event$Name[haltestelle_event$E == 2750509 & 
                       haltestelle_event$N == 1262128 ] <- "Steinach, Obersteinach Käserei"
haltestelle_event$Name[haltestelle_event$E == 2684027 & 
                       haltestelle_event$N == 1250716 ] <- "Zürich, Tierspital"
haltestelle_event$Name[haltestelle_event$E == 2693841 & 
                       haltestelle_event$N == 1230467 ] <- "Wädenswil, Campus Grüental"

# Visualisierung: Wo wurde gewartet
# ggplot(haltestelle_event)+
#   geom_sf(data = schweiz)+
#   geom_sf()+
#   theme_void() # Achsen und Raster verschwinden
```

# 3 Resultate

Die beiden Verfahren haben eine unterschiedliche Anzahl Events ergeben. So haben wir zusammen 60 (Ansatz "Geschwindigkeit"), bzw. 85 (Ansatz "Transportmodus") Reisen mit dem ÖV zurückgelegt. Miriam macht 0.51 (Ansatz "Geschwindigkeit"), bzw. 0.67 (Ansatz "Transportmodus") ÖV-Reisen pro Tag. Stefan macht 0.71 (Ansatz "Geschwindigkeit"), bzw. 1.06 (Ansatz "Transportmodus") ÖV-Reisen pro Tag.

Beim Ansatz "Geschwindigkeit" ergeben sich folgende Resultate: Miriam wartet im Mittel rund 3.1 Minuten (SD = 2.9), während Stefan im Mittel rund 1.9 Minuten (SD = 2.2) wartet. Die Wartezeiten sind von Reise zu Reise unterschiedlich lange.

```{r}
### Resultat
velocity |> 
  st_drop_geometry() |> 
  group_by(person) |> 
  summarise(Mittelwert = mean(wartezeit), Minimum = min(wartezeit), Maximum = max(wartezeit)
            , Standardabweichung = sd(wartezeit), Bereich = (max(wartezeit)-min(wartezeit)))
```

Beim Ansatz "Geschwindigkeit" ergeben sich folgende Resultate: Miriam wartet im Mittel rund 3.3 Minuten (SD = 2.8), während Stefan im Mittel rund 2.6 Minuten (SD = 2.7) wartet. Die Wartezeiten sind von Reise zu Reise unterschiedlich lange.

```{r}
### Resultat
event |> 
  st_drop_geometry() |> 
  group_by(person) |> 
  summarise(Mittelwert = mean(wartezeit_minutes), Minimum = min(wartezeit_minutes), 
            Maximum = max(wartezeit_minutes), Standardabweichung = sd(wartezeit_minutes),
            Bereich = (max(wartezeit_minutes)-min(wartezeit_minutes)))
```

Miriam wartet durschnittlich länger als Stefan an den Haltestellen (Abbildung 4). Der Unterschied ist jedoch nicht signifikant (T-Test, p=0.10 resp. p=0.25)

```{r abbildung4, fig.cap="*Abbildung 4: Vergleich der Wartezeiten von Miriam und Stefan anhand der unterschiedlichen Ansätze*"}
# Visualisierung: Vergleich Miriram & Stefan, Boxplot, beide ansätze nebeneinander...
boxplot_geschwindigkeit <- ggplot(velocity, aes(wartezeit, person, fill = person))+
  geom_boxplot()+
  guides(fill="none")+ # Legende entfernen
  scale_x_continuous( # y-Achse anpassen,
    limits = c(0, 10.1),  # Limits setzen
    breaks = c(0, 2, 4, 6, 8, 10))+ # Achsenabschnitte festlegen
  labs( # Beschriftung aendern
    title = "Ansatz 'Geschwindigkeit'", 
    x = "Wartezeit [min]", y = "Person")+
  scale_fill_manual(values = c("Miriam" = "#3182bd", "Stefan" = "#c51b8a"))+
  labs(
    fill = "Person")+ # Legende beschriften
  coord_flip() +
  geom_text(x=10.1, y=1, label="n = 25")+
  geom_text(x=10.1, y=2, label="n = 35")+
  theme_classic() # löscht ggplot-Layout

boxplot_transportmodus <- ggplot(event, aes(wartezeit_minutes, person, fill = person))+
  geom_boxplot()+
  guides(fill="none")+ # Legende entfernen
  scale_x_continuous( # y-Achse anpassen,
    limits = c(0, 10.1),  # Limits setzen
    breaks = c(0, 2, 4, 6, 8, 10))+ # Achsenabschnitte festlegen
  labs( # Beschriftung aendern
    title = "Ansatz 'Transportmodus'", 
    x = " ", y = "Person")+
  scale_fill_manual(values = c("Miriam" = "#3182bd", "Stefan" = "#c51b8a"))+
  labs(
    fill = "Person")+ # Legende beschriften
  coord_flip() +
  geom_text(x=10.1, y=1, label="n = 33")+
  geom_text(x=10.1, y=2, label="n = 52")+
  theme_classic() # löscht ggplot-Layout

boxplot_transportmodus_legende <- ggplot(event, aes(wartezeit_minutes, person, fill = person))+
  geom_boxplot()+
  labs( # Beschriftung aendern
    title = "Ansatz 'Transportmodus'", 
    x = "Wartezeit [min]", y = "Person")+
  scale_fill_manual(values = c("Miriam" = "#3182bd", "Stefan" = "#c51b8a"))+
  labs(
    fill = "Person")+ # Legende beschriften
  coord_flip() +
  theme_classic() # löscht ggplot-Layout


# plots in einer Abbildung
combined_plot <- plot_grid(boxplot_geschwindigkeit, boxplot_transportmodus, ncol = 2)

# plots in einer Abbildung
combined_plot <- plot_grid(boxplot_geschwindigkeit, boxplot_transportmodus, ncol = 2)

# extract legend from plot1
legend <- get_legend(
  boxplot_transportmodus_legende +
    guides(fill = guide_legend(nrow = 1)) +
    theme(legend.position = "bottom")
)
  
# Combine combined plot and legend using plot_grid()
plot_grid(combined_plot, legend,ncol=1,rel_heights = c(1, .1))
```

T-Test für den Ansatz "Geschwindigkeit":

```{r}
t.test(wartezeit~person, data = velocity, var.equal = TRUE)# ungepaart, zweiseitig, long-Format
```

T-Test für den Ansatz "Geschwindigkeit":

```{r}
t.test(wartezeit_minutes~person, data = event, var.equal = TRUE)# ungepaart, zweiseitig, long-Format
```

Werden die Wartezeiten in Kategorien eingeteilt, ist ersichtlich, dass diese bei den beiden Ansätzen unterschiedliche Ergebnisse zeigen (Abbildung 5). Die Verteilung der Anteile der Events sieht leicht unterschiedlich aus. Zudem gibt es je nach Ansatz und Person auch Wartezeiten von zehn Minten.

```{r abbildung5, fig.cap="*Abbildung 5: Vergleich der Wartezeiten in Kategorien von Miriam und Stefan anhand der unterschiedlichen Ansätze*"}
# Farbige Säulen pro Person, Anteil von 0-1 min, 1-2 min,...
saeule_geschwindigkeit <- ggplot(velocity, aes(person, fill = wartezeit_cat))+
  geom_bar(position = position_fill(reverse = TRUE))+
  scale_fill_manual(values = c("#00441b", "#1b7837", "#5aae61", "#a6dba0", "#d9f0d3",
                               "#e7d4e8", "#c2a5cf", "#762a83"))+
  guides(fill="none")+ # Legende
  labs(
    title = "Ansatz 'Geschwindigkeit'", # Titel setzen
    x = "Person", y = "Anteil der Events", # Achsen beschriften
    fill = "Wartezeit [min]")+ # Legende beschriften
  scale_y_continuous( # y-Achse anpassen,
    limits = c(0, 1.05),  # Limits setzen
    breaks = c(0.00, 0.25, 0.50, 0.75, 1.00))+ # Achsenabschnitte festlegen
  geom_text(x=1, y=1.05, label="n = 25")+
  geom_text(x=2, y=1.05, label="n = 35")+
  theme_classic() # löscht ggplot-Layout


# Spalte mit Kategorie der Wartezeit hinzufügen
event$wartezeit_cat <- "NA"
event$wartezeit_cat[event$wartezeit_minutes >= 0 & event$wartezeit_minutes < 1] <- "0-1"
event$wartezeit_cat[event$wartezeit_minutes >= 1 & event$wartezeit_minutes < 2] <- "1-2"
event$wartezeit_cat[event$wartezeit_minutes >= 2 & event$wartezeit_minutes < 3] <- "2-3"
event$wartezeit_cat[event$wartezeit_minutes >= 3 & event$wartezeit_minutes < 4] <- "3-4"
event$wartezeit_cat[event$wartezeit_minutes >= 4 & event$wartezeit_minutes < 5] <- "4-5"
event$wartezeit_cat[event$wartezeit_minutes >= 5 & event$wartezeit_minutes < 6] <- "5-6"
event$wartezeit_cat[event$wartezeit_minutes >= 6 & event$wartezeit_minutes < 7] <- "6-7"
event$wartezeit_cat[event$wartezeit_minutes >= 7 & event$wartezeit_minutes < 8] <- "7-8"
event$wartezeit_cat[event$wartezeit_minutes >= 8 & event$wartezeit_minutes < 9] <- "8-9"
event$wartezeit_cat[event$wartezeit_minutes >= 9 & event$wartezeit_minutes < 10] <- "9-10"

saeule_transportmodus <- ggplot(event, aes(person, fill = wartezeit_cat))+
  geom_bar(position = position_fill(reverse = TRUE))+
  scale_fill_manual(values = c("#00441b", "#1b7837", "#5aae61", "#a6dba0", "#d9f0d3",
                               "#f7f7f7","#e7d4e8", "#c2a5cf", "#9970ab","#762a83"))+
  guides(fill="none")+ # Legende
  labs(
    title = "Ansatz 'Transportmodus'", # Titel setzen
    x = "Person", y = " ", # Achsen beschriften
    fill = "Wartezeit [min]")+ # Legende beschriften
  scale_y_continuous( # y-Achse anpassen,
    limits = c(0, 1.05),  # Limits setzen
    breaks = c(0.00, 0.25, 0.50, 0.75, 1.00))+ # Achsenabschnitte festlegen
  geom_text(x=1, y=1.05, label="n = 33")+
  geom_text(x=2, y=1.05, label="n = 52")+
  theme_classic() # löscht ggplot-Layout

saeule_transportmodus_legende <- ggplot(event, aes(person, fill = wartezeit_cat))+
  geom_bar(position = position_fill(reverse = TRUE))+
  scale_fill_manual(values = c("#00441b", "#1b7837", "#5aae61", "#a6dba0", "#d9f0d3",
                               "#f7f7f7","#e7d4e8", "#c2a5cf", "#9970ab","#762a83"))+
  labs(
    title = "Ansatz 'Transportmodus'", # Titel setzen
    x = "Person", y = "Anteil der Events", # Achsen beschriften
    fill = "Wartezeit [min]")+ # Legende beschriften
  scale_y_continuous( # y-Achse anpassen,
    limits = c(0, 1.05),  # Limits setzen
    breaks = c(0.00, 0.25, 0.50, 0.75, 1.00))+ # Achsenabschnitte festlegen
  geom_text(x=1, y=1.05, label="n = 33")+
  geom_text(x=2, y=1.05, label="n = 52")+
  theme_classic() # löscht ggplot-Layout

# plots in einer Abbildung
combined_plot <- plot_grid(saeule_geschwindigkeit, saeule_transportmodus, ncol = 2)

# extract legend from plot1
legend <- get_legend(
  saeule_transportmodus_legende +
    guides(fill = guide_legend(nrow = 1)) +
    theme(legend.position = "bottom")
)
  
# Combine combined plot and legend using plot_grid()
plot_grid(combined_plot, legend,ncol=1,rel_heights = c(1, .1))

```

```{r}
### nicht verwendete Grafiken:

# violin plot (sagt nicht mehr aus als Säulen, oder?)
# ggplot(velocity, aes(wartezeit, person, fill = person))+
#   geom_violin(scale = "count")+
#   coord_flip() +
#   labs( # Beschriftung aendern
#     title = "Wartezeiten",
#     x = "Wartezeit [min]", y = "Person", fill = "Person")+
#   scale_fill_manual(values = c("Miriam" = "#3182bd", "Stefan" = "#c51b8a"))+
#   theme_classic() # löscht ggplot-Layout

# Boxplot mit Haltestelle (nur sinnvoll mit viel benutzen Haltestellen...)
# ggplot(velocity, aes(wartezeit, Name))+
#   geom_boxplot()+
#   coord_flip() +
#   labs( # Beschriftung aendern
#     title = "Wartezeiten beim Vorgehen velocity", 
#     x = "Person", y = "Wartezeit [min]")+
#   theme(axis.text.x = element_text(angle = 90, hjust = 1))+ # Text vertikal
#   theme_classic() # löscht ggplot-Layout

# Karte mit Punkt pro Haltestelle, Punktgrösse gibt Mean Wartezeit an, evtl noch eine Nummer mit Anzahl Events neben Punkt. # Interaktive Karte -> Miriam ist dran
# velocity_sum <- velocity |>
#   group_by(Name) |> # group_by(Spalte_gruppieren1, Spalte_gruppieren2)
#   summarise(Mean = mean(wartezeit), Anzahl = length(wartezeit))
# 
# ggplot(velocity_sum)+
#   geom_sf(data = schweiz)+
#   geom_sf(aes(size = Mean, colour = Anzahl))+
#   theme_void() # Achsen und Raster verschwinden

# Mosaic plot: Miriam vs. Stefan mit wartezeit_cat, sagt auch nicht so viel aus?
# ggplot() +
#   geom_mosaic(data = velocity, aes(x = product(wartezeit_cat), fill= person),
#               show.legend = FALSE) +
#   theme_mosaic()+
#   scale_fill_manual(values = c("Miriam" = "#3182bd", "Stefan" = "#c51b8a"))+
#   labs(
#     title = "Vergleich der Wartezeiten", # Titel setzen
#     y = "Person", x = "Wartezeit [min]")+ # Achsen beschriften
#   theme_classic() # löscht ggplot-Layout
```

Die folgende interaktive Karte (Abbildung 6) zeigt alle ÖV-Haltestellen mit Angaben zur Wartezeit des Ansatzes "Transportmodus" an.

```{r abbildung6, fig.cap="*Abbildung 6: Interaktive Karte mit den ÖV-Haltestellen, wo eine Reise begonnen wurde.*"}
#Interaktive Karte einfügen

#m <- leaflet() %>% 
#   addTiles() %>% 
#   setView( lng = 2.34, lat = 48.85, zoom = 5 ) %>% 
#   addProviderTiles("NASAGIBS.ViirsEarthAtNight2012")
# m

# Tabelle summary
haltestelle_event <- haltestelle_event |>
   group_by(Name, person) |> # group_by(Spalte_gruppieren1, Spalte_gruppieren2)
   summarise(Wartezeit = mean(wartezeit_minutes), Anzahl = length(wartezeit_minutes), 
             Minimum = min(wartezeit_minutes), Maximum = max(wartezeit_minutes))

#WGS Koordinaten für leaflet Karte wieder hinzufügen
# WGS Geometrie hinzufügen
eventWGS <- haltestelle_event |> 
  st_as_sf(coords = c("E", "N"), crs = 2056, remove = FALSE) |>  # Geometrie hinzufügen
  st_transform(4326) # transformieren von CH1903+ LV95 nach WGS: 2056 ->4326

# WGS Koordinaten zu sf-Tabelle hinzufügen
eventWGS_coordinates <- st_coordinates(eventWGS)
eventWGS <- cbind(eventWGS, eventWGS_coordinates)

#gerundete Wartezeiten zu eventWGS hinzufügen
eventWGS <- eventWGS |>
  mutate(
    wartezeit = round(Wartezeit, 2),
    min = round(Minimum, 2),
    max = round(Maximum, 2)
  )

#Interaktive Karte mit leaflet erstellen
mytext <- paste(
   "Haltestelle: ", eventWGS$Name, "<br/>", 
   "Person: ", eventWGS$person, "<br/>", 
   "Wartezeit ∅: ", eventWGS$wartezeit, sep="",
    ", Min.: ", eventWGS$min,
     ",  Max.: ", eventWGS$max,"<br/>",
   "Anzahl Aufenthalte: ", eventWGS$Anzahl ) %>%
  lapply(htmltools::HTML)

mybins <- seq(0, 10, by=5)
mypalette <- colorBin( palette="Blues", domain=eventWGS$wartezeit, bins=mybins)

l <- leaflet(eventWGS) %>% addTiles() %>%
  addCircleMarkers(lng = ~X, lat = ~Y,
                   fillColor = ~mypalette(wartezeit), fillOpacity = 0.8, color="black", radius=10, stroke=,
                   label = mytext) %>%
  addLegend( pal=mypalette, values=~wartezeit, opacity=0.8, title = "Wartezeit ∅", position = "bottomright" )
l
```

# 4 Diskussion

Bei der Bearbeitung der Fragestellungen stiessen wir auf einige Probleme und Grenzen. Beim Ansatz «Geschwindigkeit» ergibt sich durch das Setzen des Schwellenwertes für die Geschwindigkeit ein Problem. Wird der Schwellenwert zu tief gesetzt, können Bewegungen auf dem Weg zu der Haltestelle bereits als schnelle Bewegung eingestuft werden, obwohl wir diese als langsame Bewegungen haben möchten. Ein Beispiel: Stefan geht oft mit dem Fahrrad zur ÖV-Haltestelle und erreicht dabei Geschwindigkeiten über 40 km/h. Deshalb wurde der Schwellenwert auf 45 km/h gesetzt. Nun kann es aber sein, dass das öffentliche Verkehrsmittel beim Start der Reise langsam fährt und diese Bewegung als langsame Bewegung eingestuft wird. Dies hat zur Folge, dass sich die Wartezeit auf 10 Sekunden, also die Zeit zwischen zwei Datenpunkten beschränkt und nicht der Wahrheit entspricht. Die Daten werden verfälscht. Gschwend (2015) erwähnt solche Probleme bei der Erkennung von Stopps und Bewegungen ebenfalls und stellt in seiner Arbeit eine Bewegungs-Kontext-Relationsmatrix auf der Grundlage von Modellen vor.

Beim Ansatz «Transportmodus» sind wir auf die Qualität von Posmo angewiesen. Den Transportmodus können wir zwar manuell anpassen, die Segmente sind aber relativ fix (Erfahrungen haben gezeigt, dass die Funktion «split segment» nicht einwandfrei funktioniert). Es kam einige Male vor, dass langsame und schnelle Bewegungen am Start einer Reise als ein Segment dargestellt wurde. Der Transportmodus war dann entweder Bus, Train oder Tram. Ein Segment des Transportmodus Walk oder Bike fehlte. Daher wurde auch kein Start einer Reise erkannt. Dies hat Verluste von Datenpunkten zur Folge. Eine Verfälschung von Datenpunkten liegt aber nicht vor..

Aufgrund der Frequenz der Lokalisierung, können die Wartezeiten nur auf 10 Sekunden genau sein.

Der Ansatz «Geschwindigkeit» zeigt auf, dass die Transportmodi nicht einzig aufgrund der Geschwindigkeit eingeteilt werden können. Die Daten werden verfälscht und können nicht interpretiert werden. Der Ansatz «Transportmodus» ergibt deutlich bessere Daten. Bei diesem Ansatz waren wir aber darauf angewiesen, dass wir bereits vorgegebene Segmente hatten und diese nur noch klassifizieren oder validieren mussten. Dies ist zeitintensiv und für grössere Datensätze nicht denkbar. So können auch nur Daten bearbeitet werden, wovon man selbst weiss, welcher Transportmodus verwendet wurde.

Um die Auswertung auch auf grössere und fremde Datensätze auszuweiten, wäre eine Verbesserung der Erkennung des Transportmodus von Vorteil. Busse und Trams wurden zum Beispiel immer als Autos klassifiziert. Hierfür wäre vielleicht ein Abgleich mit Datensätzen des öffentlichen Verkehrs möglich. Zudem gab es manchmal Segmente, bei welchen der Transportmodus als unbekannt gesetzt wurde. Dennoch würde eine entsprechende Fragestellung, welche sich nur auf Zugreisen (inkl. Walk und Bike) bezieht, bereits mit der jetzigen Erkennung der Transportmodi relativ gut funktionieren. Guvensan et al. (2018) verbesserten die Transportmodus- sowie Aufenthaltserkennung markant durch die Entwicklung eines zusätzlichen Algorithmus. Die Erkennung des Transportmodus von Posmo könnte allenfalls durch einen zusätzlichen Algorithmus verbessert werden.

Abschliesend sollte erwähnt werden, wie sensibel Mobilitätsdaten sind. Selbst in einem anonymen groben Mobilitätsdatensatz sind nur wenige externe Informationen erforderlich, um die Spur einer Zielperson zu reidentifizieren (De Montjoye et al. 2013). Daher sollte unserer Meinung nach die Verwendung von Apps, welche Mobilitätsdaten aufnehmen, gut überlegt sein.

# 5 Literatur

BAV Bundesamt für Verkehr (2015). Haltestellen des öffentlichen Verkehrs, aktualisiert 2015-12-12, https://data.geo.admin.ch/ch.bav.haltestellen-oev/haltestellen-oev/haltestellen-oev_2056_de.csv.zip

Csikos, D., & Currie, G. (2008). Investigating Consistency in Transit Passenger Arrivals: Insights from Longitudinal Automated Fare Collection Data. Transportation Research Record, 2042(1), 12--19. https://doi.org/10.3141/2042-02

Datamap AG (2023), Posmo Project, Version 22.01.16, 2023

De Montjoye, Y. A., Hidalgo, C. A., Verleysen, M., & Blondel, V. D. (2013). Unique in the crowd: The privacy bounds of human mobility. Scientific reports, 3(1), 1-5.

Gschwend, C. (2015). Relating movement to geographic context: effects of preprocessing, relation methods and scale (Doctoral dissertation, University of Zurich).

Guvensan, M., Dusun, B., Can, B., & Turkmen, H. (2018). A Novel Segment-Based Approach for Improving Classification Performance of Transport Mode Detection. Sensors, 18(1), 87. MDPI AG. http://dx.doi.org/10.3390/s18010087

Kaindl, F. (2022). Reisen mit der Bahn: In welchen Ländern die Züge besonders pünktlich sind. Merkur.de https://www.merkur.de/reise/zuege-puenktlich-fernverkehr-bahn-europa-schweiz-daenemark-niederlande-zr-91977341.html#:\~:text=In%20der%20Schweiz%20fahren%20Z%C3%BCge%20am%20p%C3%BCnktlichsten%20Am,viele%20Gedanken%20%C3%BCber%20Versp%C3%A4tungen%20innerhalb%20des%20Landes%20machen.

Laube, P. (2017). Representation: Trajectories. In International Encyclopedia of Geography: People, the Earth, Environment and Technology (eds D. Richardson, N. Castree, M.F. Goodchild, A. Kobayashi, W. Liu and R.A. Marston). https://doi.org/10.1002/9781118786352.wbieg0593

Posit team (2023). RStudio: Integrated Development Environment for R, Version 2023.03.0 . Posit Software, PBC, Boston, MA. http://www.posit.co/.

R Core Team (2022). R: A language and environment for statistical computing. Version 4.2.1. R Foundation for Satistical Computing, Vienna, Austria. https://www.R-project.org/

Van Hagen, M. (2011). Waiting experience at train stations. Eburon Uitgeverij BV.
